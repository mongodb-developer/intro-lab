import Screenshot from "@site/src/components/Screenshot";
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# üëê Build a compound index following the ESR rule

In this exercise, you will build a compound index following the ESR rule, compare the query explain plans before and after creating the index, and analyze them.

## Explore the code

<Tabs groupId="server">
<TabItem value="node" label="üöÄ NodeJS/Express">

1. Open the file `server/src/indexing/borrowed-books-index.ts` file in your GitHub Codespace.

2. Examine the code to build a compound index on the `issueDetails` collection.

    ```js
    /**
    * Create the index to support the following query:
    * issueDetails.find({
    *    'user._id': userID,
    *   borrowDate: { $gte: date },
    * }, {
    *  sort: { returnedDate: -1 }
    * })
    */
    await collections?.issueDetails?.createIndex({
        // Equality
        'user._id': 1,
        // Sort
        returnedDate: 1,
        // Range
        borrowDate: 1,
    });
    ```

    :::info
    The index is created on the `issueDetails` collection to support the query that finds the issue details for a user with a specific `userID`, where the `borrowDate` is greater than or equal to a specific `date`, and sorts the results by `returnedDate` in descending order.

    This is compound index and it follows the ESR rule: Equality, Sort, and Range. This ensures optimal performance for the query.
    :::

3. Execute the script to create the compound index.

    ```bash
    npx tsx src/indexing/borrowed-books-index.ts
    ```

    After a few seconds, you should see the following output:

    ```bash
    Connecting to MongoDB Atlas...
    Connected!

    BEFORE creating the index

    Winning plan stage: COLLSCAN
    No index used
    Total documents examined: 1284
    Number of documents returned: 3

    -----------------------------

    AFTER creating the index

    Winning plan stage: IXSCAN
    Index used: user._id_1_returnedDate_1_borrowDate_1
    Total documents examined: 3
    Number of documents returned: 3
    ```

    :::info
    The script uses [explain plans](https://docs.mongodb.com/manual/reference/method/cursor.explain/) to compare the query plans before and after creating the index.

    Notice the difference in the winning plan stage and the number of documents examined before and after creating the index.
    :::


</TabItem>

<TabItem value="java" label="‚òïÔ∏è Java Spring Boot">

1. Let‚Äôs start with our `IssueDetail` record. Right now, it looks like this:
    ```java title='src/main/java/com/mongodb/devrel/library/domain/model/IssueDetail.java'
    @Document(collection = "issueDetails")
    public record IssueDetail(
        // fields ..
    ) {}
    ``` 

2. Now let‚Äôs optimize queries that need to filter or sort by multiple fields.
    For example, we often query by `user._id`, `returnedDate`, and `borrowDate` together.
    To speed this up, we can add a compound index using the **@CompoundIndex** annotation.  
   ```java title='src/main/java/com/mongodb/devrel/library/domain/model/IssueDetail.java' 
    @Document(collection = "issueDetails")
    @CompoundIndex(
            name = "user_returned_borrow_idx", 
            def = "{'user._id': 1, 'returnedDate': 1, 'borrowDate': 1}")
    public record IssueDetail(
        // fields
    ){}
    ```

    :::info
    The index is created on the `issueDetails` collection to support the query that finds the issue details for a user with a specific `userID`, where the `borrowDate` is greater than or equal to a specific `date`, and sorts the results by `returnedDate` in descending order.

    This is compound index and it follows the ESR rule: Equality, Sort, and Range. This ensures optimal performance for the query.
    :::
3. Open the `application.yml` and include the property `auto-index-creation: true`. At the end, your configuration will look like this:


    ```yaml title='src/main/resources/application.yml'
    spring:
      data:
        mongodb:
          uri: ${MONGODB_URI}
          database: library
          auto-index-creation: true
    ```

This ensures that any indexes defined in your domain models (for example, with `@Indexed`) will be created automatically by Spring Data MongoDB at startup.

1. Stop the running app.
    1. Locate the bottom panel and click on the `TERMINAL` tab.
    1. Press Ctrl+C/Cmd+c to interrupt the running app

1. Restart the app typing in the Terminal:

    ```bash
    mvn spring-boot:run
    ```
As soon as the application starts, you will see log entries showing the creation of indexes, similar to the image below.

<Screenshot url="https://github.com/mongodb-developer/library-management-system" src="img/screenshots/70-indexing/1-index-creation.png" alt="Spring Index creation" />

</TabItem>
</Tabs>

## Verify that the index is created

1. Open the **VS Code extension** (leaf icon) from the sidebar on the left.
1. Click **Add Connection**.
1. In the welcome screen, click **Connect** under the **Connect with Connection String** section.
1. Enter the MongoDB connection string from your Atlas cluster, making sure to replace the **password placeholder**.
1. Press **Enter**.
1. In the sidebar, you should now see your database. Expand the **library** database, then the **issueDetails** collection, and finally select **Indexes**.

<Screenshot url="https://github.com/mongodb-developer/library-management-system" src="img/screenshots/70-indexing/2-index-vscode.png" alt="VS Code Extension showing the collection indexes" />

## ü¶∏‚Äç‚ôÄÔ∏è Try different indexes

Modify the compound index by adding and removing fields, and observe the changes in the query explain plans.
